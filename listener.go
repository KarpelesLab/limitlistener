package limitlistener

import (
	"net"
	"sync"
	"sync/atomic"
)

// limitListener wraps a listener and overloads Accept() to ensure only a limited number of
// connections can be opened at the same time
type limitListener struct {
	net.Listener
	count    uint64
	maxCount uint64
	lock     sync.RWMutex
	cd       *sync.Cond
}

// limitListenerConn wraps a single connection that was generated by limitListener and will
// decrease the limitListener counter when the connection is closed. It is important to call
// Close() on this object once the connection can be closed
type limitListenerConn struct {
	net.Conn
	ll     *limitListener
	closed uint64
}

// New wraps the listener in a limitListener so that only a specific number of connection
// can be opened at the same time.
func New(l net.Listener, max uint64) net.Listener {
	if max <= 0 {
		return l
	}
	if ll, ok := l.(*limitListener); ok {
		atomic.StoreUint64(&ll.maxCount, max)
		return ll
	}

	ll := &limitListener{
		Listener: l,
		maxCount: max,
	}
	ll.cd = sync.NewCond(ll.lock.RLocker())

	return ll
}

// Accept waits if needed for the counter to be below the connection count limit, and will
// return any received connection on the listener. Connections are wrapped.
func (ll *limitListener) Accept() (net.Conn, error) {
	ll.lock.RLock()
	defer ll.lock.RUnlock()

	max := atomic.LoadUint64(&ll.maxCount)

	for {
		v := atomic.LoadUint64(&ll.count)
		if v >= max {
			ll.cd.Wait()
			continue
		}
		if !atomic.CompareAndSwapUint64(&ll.count, v, v+1) {
			// value changed, retry
			// we use this method so we can increment by 1 the counter before calling Accept
			// we basically count a pending Accept call as a pending connection
			continue
		}
		c, err := ll.Listener.Accept()
		if err != nil {
			// error happened
			ll.freeOne() // decrease count + wake up other listeners if any
			return c, err
		}

		// do not increment ll.count since it already factors the pending connection

		return &limitListenerConn{Conn: c, ll: ll}, nil
	}
}

// freeOne is called when a connection is closed, and will decrease the counter by one and wake
// any thread waiting for the connection count to change.
func (ll *limitListener) freeOne() {
	atomic.AddUint64(&ll.count, ^uint64(0))
	ll.cd.Broadcast()
}

func (cll *limitListenerConn) Close() error {
	if atomic.AddUint64(&cll.closed, 1) == 1 {
		// free one count
		cll.ll.freeOne()
	}
	return cll.Conn.Close()
}
