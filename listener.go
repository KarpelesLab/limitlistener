package limitlistener

import (
	"net"
	"sync/atomic"
)

// limitListener wraps a listener and overloads Accept() to ensure only a limited number of
// connections can be opened at the same time
type limitListener struct {
	net.Listener
	limit *Limiter
}

// limitListenerConn wraps a single connection that was generated by limitListener and will
// decrease the limitListener counter when the connection is closed. It is important to call
// Close() on this object once the connection can be closed
type limitListenerConn struct {
	net.Conn
	ll     *limitListener
	closed uint64
}

// New wraps the listener in a limitListener so that only a specific number of connection
// can be opened at the same time.
func New(l net.Listener, max uint64) net.Listener {
	if max <= 0 {
		return l
	}
	if ll, ok := l.(*limitListener); ok {
		ll.limit.SetMax(max)
		return ll
	}

	ll := &limitListener{
		Listener: l,
		limit:    NewLimiter(max),
	}

	return ll
}

// Accept waits if needed for the counter to be below the connection count limit, and will
// return any received connection on the listener. Connections are wrapped.
func (ll *limitListener) Accept() (net.Conn, error) {
	ll.limit.Add()
	c, err := ll.Listener.Accept()
	if err != nil {
		// error happened
		ll.limit.Done() // decrease count + wake up other listeners if any
		return c, err
	}

	// do not increment ll.count since it already factors the pending connection

	return &limitListenerConn{Conn: c, ll: ll}, nil
}

// freeOne is called when a connection is closed, and will decrease the counter by one and wake
// any thread waiting for the connection count to change.
func (ll *limitListener) freeOne() {
	ll.limit.Done()
}

func (cll *limitListenerConn) Close() error {
	if atomic.AddUint64(&cll.closed, 1) == 1 {
		// free one count
		cll.ll.freeOne()
	}
	return cll.Conn.Close()
}
