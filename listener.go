package limitlistener

import (
	"net"
	"runtime"
	"sync/atomic"
)

// limitListener wraps a listener and overloads Accept() to ensure only a limited number of
// connections can be opened at the same time
type limitListener struct {
	net.Listener
	limit *Limiter
}

// limitListenerConn wraps a single connection that was generated by limitListener and will
// decrease the limitListener counter when the connection is closed. It is important to call
// Close() on this object once the connection can be closed
type limitListenerConn struct {
	net.Conn
	ll     *limitListener
	closed uint64
}

// New wraps the listener in a limitListener so that only a specific number of connection
// can be opened at the same time.
func New(l net.Listener, max uint64) net.Listener {
	if max <= 0 {
		return l
	}
	if ll, ok := l.(*limitListener); ok {
		ll.limit.SetMax(max)
		return ll
	}

	ll := &limitListener{
		Listener: l,
		limit:    NewLimiter(max),
	}

	return ll
}

// Accept waits if needed for the counter to be below the connection count limit, and will
// return any received connection on the listener. Connections are wrapped.
func (ll *limitListener) Accept() (net.Conn, error) {
	ll.limit.Add()
	c, err := ll.Listener.Accept()
	if err != nil {
		// error happened
		ll.limit.Done() // decrease count + wake up other listeners if any
		return c, err
	}

	// do not increment ll.count since it already factors the pending connection

	res := &limitListenerConn{Conn: c, ll: ll}
	runtime.SetFinalizer(res, freeLimitListenerConn)

	return res, nil
}

// freeLimitListenerConn calls free on the connection if it is not referenced anymore, allowing
// resources freed by go's garbage collector to not block the listener.
func freeLimitListenerConn(cll *limitListenerConn) {
	cll.free()
}

// free calls Done() on the Limiter associated to the connection exactly once, and allows other
// connections to be processed.
func (cll *limitListenerConn) free() {
	if atomic.AddUint64(&cll.closed, 1) == 1 {
		// free one count
		cll.ll.limit.Done()
	}
}

func (cll *limitListenerConn) Close() error {
	cll.free()
	return cll.Conn.Close()
}
